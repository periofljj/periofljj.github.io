<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Beauty of Dev.</title>
  <subtitle>心有猛虎，细嗅蔷薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://periofljj.github.io/"/>
  <updated>2017-11-07T09:36:05.000Z</updated>
  <id>http://periofljj.github.io/</id>
  
  <author>
    <name>Peri Liang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你不知道的JavaScript读书笔记</title>
    <link href="http://periofljj.github.io/2017/11/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://periofljj.github.io/2017/11/07/你不知道的JavaScript读书笔记/</id>
    <published>2017-11-07T09:13:40.000Z</published>
    <updated>2017-11-07T09:36:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>js中的作用域，指的是为了储存管理变量而定义的一套规则。</p>
<p>js作为一种编译语言，它与一些传统的编译语言不通，并非是提前编译的。我们在提到“编译”这个行为的时候，通常有这样三个步骤。</p>
<ol>
<li>词法分析</li>
<li>语法分析，生成抽象语法树</li>
<li>生成可执行的代码</li>
</ol>
<p>在这个过程中有三个关键角色各司其职</p>
<p><strong>引擎：</strong> 从头到尾负责整个编译的过程</p>
<p><strong>编译器：</strong> 负责2.3步骤</p>
<p><strong>作用域：</strong></p>
<ol>
<li>收集维护变量</li>
<li>查找变量</li>
<li>定义规则确定变量访问权限</li>
</ol>
<h4 id="那么在var-a-2这个简单的声明执行的过程中，它们又是如何配合工作的呢？"><a href="#那么在var-a-2这个简单的声明执行的过程中，它们又是如何配合工作的呢？" class="headerlink" title="那么在var a = 2这个简单的声明执行的过程中，它们又是如何配合工作的呢？"></a>那么在var a = 2这个简单的声明执行的过程中，它们又是如何配合工作的呢？</h4><p>1.编译器首先向作用域确认是否有这个变量存在于当前作用域集合中</p>
<ul>
<li>有，忽略</li>
<li>没有，在当前作用于集合中创建这个变量</li>
</ul>
<p>2.编译器生成可执行的代码给引擎处理“赋值”这个动作。引擎在作用域中逐级查询这个变量（因为存在作用域嵌套）。</p>
<ul>
<li>找到，为它赋值</li>
<li>没找到，抛出referenceError</li>
</ul>
<h5 id="顺便说明引擎查询有两类：LHS（赋值）与RHS（溯源）"><a href="#顺便说明引擎查询有两类：LHS（赋值）与RHS（溯源）" class="headerlink" title="顺便说明引擎查询有两类：LHS（赋值）与RHS（溯源）"></a>顺便说明引擎查询有两类：LHS（赋值）与RHS（溯源）</h5><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包，作为js中很重要的概念，对其进行阐述。</p>
<p><strong>将内部函数传递到所在的词法作用域之外，内部函数仍持有对原始定义作用域的引用。</strong></p>
<p>例如：B函数嵌套在A函数内部，将B函数作为A函数的返回值。B函数持有对A函数作用域的引用，这个引用叫做闭包。并且A函数的作用域不会被垃圾回收，而是停留在内存中。</p>
<p>“模块”是js利用闭包的一个很好的例子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h4&gt;&lt;p&gt;js中的作用域，指的是为了储存管理变量而定义的一套规则。&lt;/p&gt;
&lt;p&gt;js作为一种编译语言，它与一些传统的编译语言不通，并非是提前编译的。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://periofljj.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript函数式编程的介绍</title>
    <link href="http://periofljj.github.io/2017/07/19/JavaScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://periofljj.github.io/2017/07/19/JavaScript函数式编程的介绍/</id>
    <published>2017-07-19T10:10:21.000Z</published>
    <updated>2017-09-20T08:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>最近在学习函数式编程相关的概念，自己尝试翻译了国外的一篇优秀技术文章，原文地址如下。如有好的建议，请尝试评论或者邮件跟我联系。</em></strong></p>
<p><a href="https://opensource.com/article/17/6/functional-javascript" target="_blank" rel="external">原文链接</a></p>
<p>1995年，当Brendan Eich着手创建<code>JavaScript</code>时，他本打算实现一个浏览器中的<code>Scheme</code>。<code>Scheme</code>，作为<code>Lisp</code>的方言，是一种函数式编程语言。但当被告知新的语言应当是一种<code>Java</code>相关的脚本语言后，他改变主意确立了一种具有C语言风格语法(就像<code>Java</code>)的语言,还支持<code>first-class function</code>(即函数可以被当做参数传递给其他的函数，作为其他函数的返回值，也可以被赋给变量)。Java直到version 8,才从技术上支持<code>first-class function</code>，当然你可以使用匿名类(anonymous classes)来模拟<code>first-class functions</code>。这些<code>first-class functions</code>使得函数式编程在<code>JavaScript</code>中成为可能。</p>
<p><code>JavaScript</code>是一种多范式的语言，它允许你在编程中自由的混搭面向对象式，过程式和函数式的范式。最近，函数式编程的方式愈受青睐。在前端框架诸如<code>Angular</code>,<code>React</code>中，采用不变的数据结构能极大的提升性能。不变性是函数式编程的核心特性。它和纯函数使得你的代码更易于发现和调试错误。摒弃程序循环而采用函数能增加代码的可读性，并且让它看起来更加优雅。总的来说，函数式编程有很多的好处。</p>
<h3 id="什么不是函数式编程？"><a href="#什么不是函数式编程？" class="headerlink" title="什么不是函数式编程？"></a>什么不是函数式编程？</h3><p>在我们讨论函数式编程之前，应该先明确怎样不算是函数式编程。让我们谈谈在编写代码中你应该抛弃的语言结构:</p>
<ul>
<li><p><strong>Loops</strong></p>
<ul>
<li>while</li>
<li>do…while</li>
<li>for</li>
<li>for…of</li>
<li>for…in</li>
</ul>
</li>
<li><p><strong>使用var或者let进行变量声明</strong></p>
</li>
<li><p><strong>Void关键字声明的函数，即函数没有返回值</strong></p>
</li>
<li><p><strong>修改对象的值(e.g., o.x = 5;)</strong></p>
</li>
<li><p><strong>修改Array的方法</strong></p>
<ul>
<li>copyWithin</li>
<li>fill</li>
<li>pop</li>
<li>push</li>
<li>reverse</li>
<li>shift</li>
<li>sort</li>
<li>splice</li>
<li>unshift</li>
</ul>
</li>
<li><p><strong>修改Map的方法</strong></p>
<ul>
<li>clear</li>
<li>delete</li>
<li>set</li>
</ul>
</li>
<li><p><strong>修改Set的方法</strong></p>
<ul>
<li>add</li>
<li>clear</li>
<li>delete</li>
</ul>
</li>
</ul>
<p>但是你的代码中怎能没有这些特性呢？这是我们在接下来的几节中药讨论的。</p>
<h3 id="纯函数-Pure-functions"><a href="#纯函数-Pure-functions" class="headerlink" title="纯函数(Pure functions)"></a>纯函数(Pure functions)</h3><p>仅仅因为你的代码中包含函数并不代表你正在实践函数式编程。函数式编程通过编写的函数是纯函数还是非纯函数区分，它鼓励你编写纯函数。一个纯函数应该满足以下所有特性。</p>
<ul>
<li><strong>引用透明性</strong>：调用此函数，相同的参数对应相同的返回值。这意味着这个函数不应该依赖于任何可变状态。</li>
<li><strong>零副作用</strong>：这个函数不应该引发任何的副作用，此处的副作用包括但不限于：；I/O（e.g.,写入控制台或者日志文件），试图修改一个可变对象，重新赋值一个变量。</li>
</ul>
<p>让我们举几个例子阐明这个概念。首先，乘法函数就是一个纯函数的例子，相同的参数值总是对应同样的输出值，并且不会引起任何的副作用。如果乘法函数会将日志记录到控制台，就会成为一个非纯函数因为它引发了一个I/O副作用。</p>
<p>接下来是非纯函数的例子。<strong>canRide()</strong> 这个函数依赖于捕获 <strong>heightRequirement</strong> 变量(ps:闭包引用外部变量称为变量捕获，captured variable)。仅是捕获变量不一定会使函数不纯，但是捕获可变(或者说可被重新赋值)的变量会。在此种情况下，变量通过let关键字声明，这意味着此变量可被重新赋值。</p>
<p>以下的列表包含几个JavaScript的内部功能，它们是非纯函数。你可以说出它们不满足被称为纯函数必要的哪个条件吗？</p>
<ul>
<li><strong>console.log</strong></li>
<li><strong>element.addEventListener</strong></li>
<li><strong>Math.random</strong></li>
<li><strong>Date.now</strong></li>
<li><strong>$.ajax($代表你选择的Ajax库)</strong></li>
</ul>
<p>所有函数都是纯函数的情景虽然很完美，但是你可以从上面的列表看出，任何有意义的代码都会包含非纯函数。大多数时候我们都需要调用Ajax call，查看当前日期或者获得一个随机数。一个好的标准是遵循80/20原则：80%的函数应当是纯函数；剩下的20%，如果均为必要，可以是非纯函数。</p>
<p>以下是纯函数的一些好处：</p>
<ul>
<li>代码会易于发现和调试错误,因其不依赖于任何可变状态。</li>
<li>返回值可以被缓存以避免在将来重新计算它。</li>
<li>易于测试,因其没有任何的依赖项(例如日志记录、Ajax、数据库等).</li>
</ul>
<p>如果你一个你正在编写或者使用的函数是用Void关键字声明的，这个特征代表它是一个非纯函数。如果一个函数没有返回值，那么要么它是一个空操作，要么它会带来一些副作用。同理可得，如果你调用了一个函数但不使用它的返回值，你很可能使用它去产生一些副作用，并且它是一个非纯函数。</p>
<h3 id="不可变性-Immutability"><a href="#不可变性-Immutability" class="headerlink" title="不可变性(Immutability)"></a>不可变性(Immutability)</h3><p>让我们回到捕获变量的概念上。上文中我们简单的讨论了 <strong>canRide()</strong> 函数。我们说它是一个非纯函数，因为变量 <strong>heightRequirement</strong> 允许被重新赋值。这里有个人为的例子来说明它是怎样由于被重新赋值而引起不可预测的后果的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> heightRequirement = <span class="number">46</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">canRide</span>(<span class="params">height</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> height &gt;= heightRequirement;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Every half second, set heightRequirement to a random number between 0 and 200.</span></div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> heightRequirement = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">201</span>), <span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> mySonsHeight = <span class="number">47</span>;</div><div class="line"></div><div class="line"><span class="comment">// Every half second, check if my son can ride.</span></div><div class="line"><span class="comment">// Sometimes it will be true and sometimes it will be false.</span></div><div class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(canRide(mySonsHeight)), <span class="number">500</span>);</div></pre></td></tr></table></figure>
<p>重新强调一下捕获变量不一定会使一个函数不纯。我们可以重写 <strong>canRide()</strong> 函数，仅仅改变声明 <strong>heightRequirement</strong> 这个变量的方式，就能使其成为纯函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> heightRequirement = <span class="number">46</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">canRide</span>(<span class="params">height</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> height &gt;= heightRequirement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用关键字 <strong>const</strong> 来声明变量意味着这是一个常量。如果尝试对它重新赋值，服务器会报错。那么，如果我们决定使用一个对象来存储常量呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> constants = &#123;</div><div class="line">  <span class="attr">heightRequirement</span>: <span class="number">46</span>,</div><div class="line">  <span class="comment">// ... other constants go here</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">canRide</span>(<span class="params">height</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> height &gt;= constants.heightRequirement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用关键字 <strong>const</strong> 来声明变量意味着这是一个常量。如果尝试对它重新赋值，服务器会报错。所以可以使用 <strong>const</strong> 关键字来声明变量避免值被修改，但是这里仍然有个问题，对象可以被修改。为了实现真正的不可变性，不仅要避免变量被重新赋值，并且数据结构也要不可变。JavaScript提供给我们一个方法—— <strong>Object.freeze</strong> 来防止对象被改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="comment">// CASE 1: The object is mutable and the variable can be reassigned.</span></div><div class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Mutate the object</span></div><div class="line">o1.foo = <span class="string">'something different'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Reassign the variable</span></div><div class="line">o1 = &#123; <span class="attr">message</span>: <span class="string">"I'm a completely new object"</span> &#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// CASE 2: The object is still mutable but the variable cannot be reassigned.</span></div><div class="line"><span class="keyword">const</span> o2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Can still mutate the object</span></div><div class="line">o2.foo = <span class="string">'Something different, yet again'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Cannot reassign the variable</span></div><div class="line"><span class="comment">// o2 = &#123; message: 'I will cause an error if you uncomment me' &#125;; // Error!</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// CASE 3: The object is immutable but the variable can be reassigned.</span></div><div class="line"><span class="keyword">let</span> o3 = <span class="built_in">Object</span>.freeze(&#123; <span class="attr">foo</span>: <span class="string">"Can't mutate me"</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// Cannot mutate the object</span></div><div class="line"><span class="comment">// o3.foo = 'Come on, uncomment me. I dare ya!'; // Error!</span></div><div class="line"></div><div class="line"><span class="comment">// Can still reassign the variable</span></div><div class="line">o3 = &#123; <span class="attr">message</span>: <span class="string">"I'm some other object, and I'm even mutable -- so take that!"</span> &#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// CASE 4: The object is immutable and the variable cannot be reassigned. This is what we want!!!!!!!!</span></div><div class="line"><span class="keyword">const</span> o4 = <span class="built_in">Object</span>.freeze(&#123; <span class="attr">foo</span>: <span class="string">'never going to change me'</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">// Cannot mutate the object</span></div><div class="line"><span class="comment">// o4.foo = 'talk to the hand' // Error!</span></div><div class="line"></div><div class="line"><span class="comment">// Cannot reassign the variable</span></div><div class="line"><span class="comment">// o4 = &#123; message: "ain't gonna happen, sorry" &#125;; // Error</span></div></pre></td></tr></table></figure>
<p>不可变性适用于所有的数据结构，包括arrays, maps, sets。这意味着我们不应当去调用修改它们的方法，就像 <strong>array.protptype.push</strong> 。因为它能修改已经存在的数组。我们可以创建一个和原先数组完全一样的新数组用于添加新的元素。事实上，每个类似的修改对象元素的方法都可以被替换为一个函数，它返回一个已按需修改的全新数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: a.push(7, 8, 9);</span></div><div class="line"><span class="keyword">const</span> b = a.concat(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: a.pop();</span></div><div class="line"><span class="keyword">const</span> c = a.slice(<span class="number">0</span>, <span class="number">-1</span>);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: a.unshift(1, 2, 3);</span></div><div class="line"><span class="keyword">const</span> d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].concat(a);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: a.shift();</span></div><div class="line"><span class="keyword">const</span> e = a.slice(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: a.sort(myCompareFunction);</span></div><div class="line"><span class="keyword">const</span> f = R.sort(myCompareFunction, a); <span class="comment">// R = Ramda</span></div><div class="line"></div><div class="line"><span class="comment">// Instead of: a.reverse();</span></div><div class="line"><span class="keyword">const</span> g = R.reverse(a); <span class="comment">// R = Ramda</span></div><div class="line"></div><div class="line"><span class="comment">// Exercise for the reader:</span></div><div class="line"><span class="comment">// copyWithin</span></div><div class="line"><span class="comment">// fill</span></div><div class="line"><span class="comment">// splice</span></div></pre></td></tr></table></figure></p>
<p>当我们在使用Map 或者Set的时候也是如此。尽量避免修改原有的数据结构，而是返回一个已按需改变的新Map或Set结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</div><div class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</div><div class="line">  [<span class="number">3</span>, <span class="string">'three'</span>]</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: map.set(4, 'four');</span></div><div class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([...map, [<span class="number">4</span>, <span class="string">'four'</span>]]);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: map.delete(1);</span></div><div class="line"><span class="keyword">const</span> map3 = <span class="keyword">new</span> <span class="built_in">Map</span>([...map].filter(<span class="function">(<span class="params">[key]</span>) =&gt;</span> key !== <span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="comment">// Instead of: map.clear();</span></div><div class="line"><span class="keyword">const</span> map4 = <span class="keyword">new</span> <span class="built_in">Map</span>();</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: set.add('D');</span></div><div class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set, <span class="string">'D'</span>]);</div><div class="line"></div><div class="line"><span class="comment">// Instead of: set.delete('B');</span></div><div class="line"><span class="keyword">const</span> set3 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">'B'</span>));</div><div class="line"></div><div class="line"><span class="comment">// Instead of: set.clear();</span></div><div class="line"><span class="keyword">const</span> set4 = <span class="keyword">new</span> <span class="built_in">Set</span>();</div></pre></td></tr></table></figure>
<p>另外，如果你正在使用TypeScript编程，你可以使用 <strong>Readonly<t></t></strong>，<strong>ReadonlyArray<t></t></strong>，<strong>ReadonlyMap<k, v=""></k,></strong>，和 <strong>ReadonlySet<t></t></strong>。这样如果你试图修改任何的对象，都会编译报错。如果你对一个对象字面量或者数组调用 <strong>Object.freeze</strong> ,那么编译器会自动的指出它们是read-only的。由于Maps和Sets在内部表达的方式,对于这些数据结构调用 <strong>Object.freeze</strong> 的工作原理并不相同。但是能够轻易的告诉编译器你希望他们的是read-only的。</p>
<p><img src="/2017/07/19/JavaScript函数式编程的介绍/typescript-readonly.png" alt="TypeScript read-only interfaces"></p>
<p>好的，所以我们已经了解到选择创建一个新的对象而不是修改原对象，能够避免为性能带来负面影响。记得要在自己开发的app中做性能测试。如果你需要提升性能，可以考虑使用 <strong>Immutable.js</strong> 。这个库使用稳定的数据结构实现了Lists, Stacks, Maps, Sets和其他的数据结构。这和诸如Clojure, Scala这类函数式编程语言使用了相同的内部技术。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Use in place of `[]`.</span></div><div class="line"><span class="keyword">const</span> list1 = Immutable.List([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line"><span class="keyword">const</span> list2 = list1.push(<span class="string">'D'</span>, <span class="string">'E'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log([...list1]); <span class="comment">// ['A', 'B', 'C']</span></div><div class="line"><span class="built_in">console</span>.log([...list2]); <span class="comment">// ['A', 'B', 'C', 'D', 'E']</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Use in place of `new Map()`</span></div><div class="line"><span class="keyword">const</span> map1 = Immutable.Map([</div><div class="line">  [<span class="string">'one'</span>, <span class="number">1</span>],</div><div class="line">  [<span class="string">'two'</span>, <span class="number">2</span>],</div><div class="line">  [<span class="string">'three'</span>, <span class="number">3</span>]</div><div class="line">]);</div><div class="line"><span class="keyword">const</span> map2 = map1.set(<span class="string">'four'</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log([...map1]); <span class="comment">// [['one', 1], ['two', 2], ['three', 3]]</span></div><div class="line"><span class="built_in">console</span>.log([...map2]); <span class="comment">// [['one', 1], ['two', 2], ['three', 3], ['four', 4]]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Use in place of `new Set()`</span></div><div class="line"><span class="keyword">const</span> set1 = Immutable.Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]);</div><div class="line"><span class="keyword">const</span> set2 = set1.add(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log([...set1]); <span class="comment">// [1, 2, 3, 4]</span></div><div class="line"><span class="built_in">console</span>.log([...set2]); <span class="comment">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure></p>
<h3 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化(Currying)"></a>柯里化(Currying)</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;最近在学习函数式编程相关的概念，自己尝试翻译了国外的一篇优秀技术文章，原文地址如下。如有好的建议，请尝试评论或者邮件跟我联系。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://opensource.com/article/
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://periofljj.github.io/tags/JavaScript/"/>
    
      <category term="英文翻译" scheme="http://periofljj.github.io/tags/%E8%8B%B1%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>程序媛数据结构与算法进阶（一）</title>
    <link href="http://periofljj.github.io/2017/03/20/algorithm1/"/>
    <id>http://periofljj.github.io/2017/03/20/algorithm1/</id>
    <published>2017-03-20T06:27:34.000Z</published>
    <updated>2017-03-20T10:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-复杂度分析"><a href="#1-复杂度分析" class="headerlink" title="1. 复杂度分析"></a>1. 复杂度分析</h2><h2 id="1-1-究竟什么是大O"><a href="#1-1-究竟什么是大O" class="headerlink" title="1.1 究竟什么是大O"></a>1.1 究竟什么是大O</h2><p>假设n表示数据规模，那么<strong>O(f(n))</strong> 的定义是——运行算法所需执行的指令数，和f(n)成正比，也代表算法执行的上界。即：</p>
<table>
<thead>
<tr>
<th style="text-align:left">时间复杂度</th>
<th style="text-align:left">运行算法所需执行的指令数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">O($\log n$)</td>
<td style="text-align:left">a * $\log n$</td>
</tr>
<tr>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">b * n</td>
</tr>
<tr>
<td style="text-align:left">O(n$\log n$)</td>
<td style="text-align:left">c * (n$\log n$)</td>
</tr>
<tr>
<td style="text-align:left">O($n^2$)</td>
<td style="text-align:left">d * $n^2$</td>
</tr>
</tbody>
</table>
<p>参考下图，当数据规模相同时，不同时间复杂度算法用时的比较。</p>
<p><img src="/2017/03/20/algorithm1/timecompare.png" alt="图1-不同时间复杂度算法对比图"></p>
<p>我们可以发现当数据规模小到一定程度时，时间复杂度高的算法也是有意义的。</p>
<p>当数据规模相同的时候，假设O($n\log n$ + n)这个时间复杂度我们可以直接看做O($n\log n$),而O($n\log n$ + n^2)视为O(n^2)。因为我们只看f(n)表达式里作用最显著的部分。但是O($A\log A$ + B)不能简单的视为O($A\log A$ )，这是因为A、B是不同问题的规模。</p>
<h3 id="例题1-1：有一个字符串数组，将数组中的每一个字符串按照字母序排列；之后再将整个字符串数组按照字典序排列。整个操作的时间复杂度。"><a href="#例题1-1：有一个字符串数组，将数组中的每一个字符串按照字母序排列；之后再将整个字符串数组按照字典序排列。整个操作的时间复杂度。" class="headerlink" title="例题1-1：有一个字符串数组，将数组中的每一个字符串按照字母序排列；之后再将整个字符串数组按照字典序排列。整个操作的时间复杂度。"></a>例题1-1：有一个字符串数组，将数组中的每一个字符串按照字母序排列；之后再将整个字符串数组按照字典序排列。整个操作的时间复杂度。</h3><p>答案：假设最长的字符串长度为s；数组中有n个字符串。对每个字符串排序：O($s\log s$),<br>遍历将数组中的每一个字符串按照字母序排序：O($n \times s\log s$).又有整形数组排序的时间复杂度为O（$n\log n$）,则对整个字符串数组按照字典序排序为O（$s \times n\log n$）.所以整个操作的时间复杂度为O($n \times s\log s$)+O（$s \times n\log n$）.</p>
<h4 id="常见排序算法时间复杂度"><a href="#常见排序算法时间复杂度" class="headerlink" title="常见排序算法时间复杂度"></a>常见排序算法时间复杂度</h4><p><img src="/2017/03/20/algorithm1/sort-compare.png" alt="图2-各种排序的比较图"></p>
<p>我们通常只需要关注一般情况就好。</p>
<h2 id="1-2-对数据规模有个概念"><a href="#1-2-对数据规模有个概念" class="headerlink" title="1.2 对数据规模有个概念"></a>1.2 对数据规模有个概念</h2><p>如果想要在1s内解决问题，不同时间复杂度可处理级别的数据为下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">时间复杂度</th>
<th style="text-align:left">数据规模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">O($n^2$)</td>
<td style="text-align:left">$10^4$</td>
</tr>
<tr>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">$10^8$</td>
</tr>
<tr>
<td style="text-align:left">O($n\log n$)</td>
<td style="text-align:left">$10^7$</td>
</tr>
</tbody>
</table>
<h2 id="1-3-空间复杂度"><a href="#1-3-空间复杂度" class="headerlink" title="1.3 空间复杂度"></a>1.3 空间复杂度</h2><p>开了多大的辅助空间，就说用了多少空间复杂度。</p>
<ul>
<li>多开了一个辅助的数组：O(n)</li>
<li>多开了一个辅助的二维数组：O($n^2$)</li>
<li>多开了一块常数空间：O(1)</li>
</ul>
<h3 id="PS：递归的调用是有空间代价的。递归的深度是多少，空间复杂度就是多少。"><a href="#PS：递归的调用是有空间代价的。递归的深度是多少，空间复杂度就是多少。" class="headerlink" title="PS：递归的调用是有空间代价的。递归的深度是多少，空间复杂度就是多少。"></a>PS：递归的调用是有空间代价的。递归的深度是多少，空间复杂度就是多少。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-复杂度分析&quot;&gt;&lt;a href=&quot;#1-复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;1. 复杂度分析&quot;&gt;&lt;/a&gt;1. 复杂度分析&lt;/h2&gt;&lt;h2 id=&quot;1-1-究竟什么是大O&quot;&gt;&lt;a href=&quot;#1-1-究竟什么是大O&quot; class=&quot;
    
    </summary>
    
    
      <category term="算法" scheme="http://periofljj.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>客户端存储小结</title>
    <link href="http://periofljj.github.io/2017/02/16/web-storage/"/>
    <id>http://periofljj.github.io/2017/02/16/web-storage/</id>
    <published>2017-02-16T09:53:56.000Z</published>
    <updated>2017-03-01T08:25:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人在工作和面试中常常遇到有关客户端存储的问题，于是系统性的总结如下，与各位共同进步。</p>
<h3 id="客户端存储的意义"><a href="#客户端存储的意义" class="headerlink" title="客户端存储的意义"></a>客户端存储的意义</h3><p>Web应用允许使用浏览器提供的API实现将数据存储到用户的电脑上。这种客户端存储相当于赋予了Web浏览器记忆功能。比方说，Web应用就可以用这种方式来“记住”用户的偏好甚至是用户所有的状态信息，以便准确地”回忆“起用户上一次访问的位置。</p>
<h3 id="客户端存储“同源策略”"><a href="#客户端存储“同源策略”" class="headerlink" title="客户端存储“同源策略”"></a>客户端存储“同源策略”</h3><p>不同站点的页面无法读取对方存储的数据，同一站点的不同页面可以互相共享存储数据，它为我们提供了一种通信机制。例如，一个页面上填写的表单数据可以显示在另外一个页面中。</p>
<h3 id="客户端存储的有效期"><a href="#客户端存储的有效期" class="headerlink" title="客户端存储的有效期"></a>客户端存储的有效期</h3><p>Web应用可以选择它们存储数据的有效期：</p>
<ul>
<li>临时存储：保存至当前窗口关闭或者浏览器退出。</li>
<li>永久存储：将数据永久地存储到硬盘上，数月甚至数年不时效。</li>
</ul>
<h3 id="客户端存储形式"><a href="#客户端存储形式" class="headerlink" title="客户端存储形式"></a>客户端存储形式</h3><h3 id="1-Web存储"><a href="#1-Web存储" class="headerlink" title="1. Web存储"></a>1. Web存储</h3><h4 id="1-1-什么是Web存储"><a href="#1-1-什么是Web存储" class="headerlink" title="1.1 什么是Web存储"></a>1.1 什么是Web存储</h4><p>Web存储标准所描述的API包含 <strong>localStorage</strong> 对象和 <strong>sessionStorage</strong> 对象，这两个对象实际上是持久化关联数组，是名值对的映射表，名和值都是字符串。</p>
<p>优点如下：</p>
<ul>
<li>易于使用</li>
<li>支持大容量存储（并非无限量）</li>
<li>兼容当前所有主流浏览器（但是不兼容早期浏览器）</li>
</ul>
<hr>
<h4 id="1-2-localStorage和sessionStorage的使用"><a href="#1-2-localStorage和sessionStorage的使用" class="headerlink" title="1.2 localStorage和sessionStorage的使用"></a>1.2 localStorage和sessionStorage的使用</h4><p><strong>localStorage</strong> 和 <strong>sessionStorage</strong> 同为Window对象的属性。这两个属性代表了同一个 <strong>Storage</strong> 对象，即一个持久化关联数组，它通过string索引和存储。Storage对象在使用上和一般的JavaScript对象没什么区别，即对象的属性为字符串，随后浏览器会将值储存起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"storage"</span>&#125;; <span class="comment">//JS对象的创建</span></div></pre></td></tr></table></figure>
<p>目前浏览器仅支持字符串类型存储，若希望存储和获取其他数据类型，需要手动编码解码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//number</span></div><div class="line">localStorage.x = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> x = <span class="built_in">parseInt</span>(localStorage.x);</div><div class="line"></div><div class="line"><span class="comment">//data</span></div><div class="line">localStorage.lastRead = (<span class="keyword">new</span> <span class="built_in">Date</span>()).toUTCString();</div><div class="line"><span class="keyword">var</span> lastRead = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(localStorage.lastRead));</div><div class="line"></div><div class="line"><span class="comment">//JSON</span></div><div class="line">localStorage.data = <span class="built_in">JSON</span>.stringify(data);</div><div class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(localStorage.data);</div></pre></td></tr></table></figure></p>
<hr>
<h4 id="1-3-localStorage和sessionStorage的对比"><a href="#1-3-localStorage和sessionStorage的对比" class="headerlink" title="1.3 localStorage和sessionStorage的对比"></a>1.3 localStorage和sessionStorage的对比</h4><p><strong>localStorage</strong> 和 <strong>sessionStorage</strong> 区别在于存储的有效期和作用域的不同，对比如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">localStorage</th>
<th style="text-align:left">sessionStorage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">有效期</td>
<td style="text-align:left">永久，除非Web应用或用户刻意删除</td>
<td style="text-align:left">与存储数据的脚本所在最顶层的窗口或者是浏览器标签页是一样的</td>
</tr>
<tr>
<td style="text-align:left">作用域</td>
<td style="text-align:left">限定在文档源（主机名、协议、端口）级别，同源的文档共享同样的localStorage数据，可以互相读取覆盖。</td>
<td style="text-align:left">限定在文档源+窗口中。同源的文档渲染在不同的浏览器标签页中，彼此无法共享sessionStorage数据。</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="1-4-存储API"><a href="#1-4-存储API" class="headerlink" title="1.4 存储API"></a>1.4 存储API</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setItem()    <span class="comment">//向对象传值</span></div><div class="line">getItem()    <span class="comment">// 参数为属性名，获取对应的值</span></div><div class="line">removeItem() <span class="comment">//参数为属性名，删除对应数据</span></div><div class="line">clear()      <span class="comment">//删除所有存储的数据</span></div><div class="line">key()        <span class="comment">//传入0 ~ length-1的数字，获得此处存储数据名字</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="1-5-存储事件"><a href="#1-5-存储事件" class="headerlink" title="1.5 存储事件"></a>1.5 存储事件</h4><p>一旦存储在localStorage或者sessionStorage的数据发生改变，浏览器都会在其他对该数据可见的窗口对象上触发存储事件（但是，在对数据进行改变的窗口对象上是不会触发的。）</p>
<p>与存储事件相关的事件对象有五个重要属性：</p>
<ul>
<li><strong>key</strong> //被设置或者移除的项的名字或者键名</li>
<li><strong>newValue</strong> //保存该项的新值</li>
<li><strong>oldValue</strong> //改变或者删除该项前，保存该项原先的值。若插入新项则为null</li>
<li><strong>storageArea</strong> //目标Window对象上的localStorage属性或者是sessionStorage属性。</li>
<li><strong>url</strong> //触发该存储变化脚本所在文档的url</li>
</ul>
<hr>
<h3 id="2-cookie"><a href="#2-cookie" class="headerlink" title="2. cookie"></a>2. cookie</h3><p>cookie是一种早期的客户端存储机制，起初是针对服务器端脚本设计使用的。客户端提供的JavaScript API繁琐难于使用。但是新旧浏览器都支持它，兼容性完胜。</p>
<p>特点如下：</p>
<ul>
<li>只适合存储少量文本数据</li>
<li>任何以cookie形式存储的数据，不论服务器是否需要，每一次HTTP请求都会把这些数据传输到服务器端。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人在工作和面试中常常遇到有关客户端存储的问题，于是系统性的总结如下，与各位共同进步。&lt;/p&gt;
&lt;h3 id=&quot;客户端存储的意义&quot;&gt;&lt;a href=&quot;#客户端存储的意义&quot; class=&quot;headerlink&quot; title=&quot;客户端存储的意义&quot;&gt;&lt;/a&gt;客户端存储的意义&lt;/h
    
    </summary>
    
      <category term="Technology" scheme="http://periofljj.github.io/categories/Technology/"/>
    
    
      <category term="JavaScript" scheme="http://periofljj.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>H5实现移动端可视化数据报告开发笔记</title>
    <link href="http://periofljj.github.io/2017/01/05/hello-world/"/>
    <id>http://periofljj.github.io/2017/01/05/hello-world/</id>
    <published>2017-01-05T03:47:01.000Z</published>
    <updated>2017-03-01T08:16:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近自己学习用H5实现移动端可视化数据报告，即通过H5和其他前端技术将数据通过图表组件（饼图、折线图等）的方式直观的呈现在用户眼前。整个过程，尤其是组件化开发思想让自己受益匪浅，以下是按照学习和开发的流程总结的要点以供参考。</p>
<p><a href="https://github.com/periofljj/h5-dataVisualizationReport" target="_blank" rel="external">点击下载源代码</a></p>
<h2 id="Web开发流程简析"><a href="#Web开发流程简析" class="headerlink" title="Web开发流程简析"></a>Web开发流程简析</h2><h3 id="开发前"><a href="#开发前" class="headerlink" title="开发前"></a>开发前</h3><p>要进行功能设计和视觉/交互设计。</p>
<h3 id="开发中"><a href="#开发中" class="headerlink" title="开发中"></a>开发中</h3><ul>
<li>必要的技术规划</li>
<li>前端开发</li>
<li>后端开发</li>
</ul>
<h3 id="开发后"><a href="#开发后" class="headerlink" title="开发后"></a>开发后</h3><p>测试、上线</p>
<h2 id="前端开发要点总结"><a href="#前端开发要点总结" class="headerlink" title="前端开发要点总结"></a>前端开发要点总结</h2><h3 id="Step1-标注"><a href="#Step1-标注" class="headerlink" title="Step1.标注"></a>Step1.标注</h3><p><a href="http://www.getmarkman.com" target="_blank" rel="external">MarkMan</a> - 个人非常推荐的一款前端工程师切图标注工具。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>首先要划分图片模块和文字区域模块。</li>
<li>手机端UI设计元素尺寸一般都为偶数。因为移动端双倍分辨率下所有宽、高都必须是偶数，如果设计图不符合要求需要手动调整。</li>
<li>一个模块的位置，即x轴和y轴，必须定义一个。</li>
<li>移动端边距主要标注比例而不是具体的值。</li>
<li>标注文本却与要考虑行高。</li>
</ul>
<h3 id="Step2-切图"><a href="#Step2-切图" class="headerlink" title="Step2.切图"></a>Step2.切图</h3><ul>
<li>合并图层：<code>command</code> + <code>E</code> / 按住 <code>command</code> 鼠标变成选区模式。</li>
<li>另存为web格式：<code>command</code>+<code>shift</code>+<code>alt</code>+<code>s</code>。如果元素有透明的背景，则需要存在png24格式。</li>
</ul>
<h3 id="Step3-项目类JS开发"><a href="#Step3-项目类JS开发" class="headerlink" title="Step3.项目类JS开发"></a>Step3.项目类JS开发</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近自己学习用H5实现移动端可视化数据报告，即通过H5和其他前端技术将数据通过图表组件（饼图、折线图等）的方式直观的呈现在用户眼前。整个过程，尤其是组件化开发思想让自己受益匪浅，以下是按照学习和开发的流程总结的要点以供参考。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://
    
    </summary>
    
    
      <category term="H5" scheme="http://periofljj.github.io/tags/H5/"/>
    
      <category term="组件开发" scheme="http://periofljj.github.io/tags/%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
